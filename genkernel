#!/bin/bash
# Genkernel v3

PATH="/bin:/usr/bin:/sbin:/usr/sbin"
GK_V='3.3.11c'

TMPDIR='/var/tmp/genkernel'
TODEBUGCACHE=1 # Until an error occurs or DEBUGFILE is fully qualified.

small_die() {
  echo $1
  exit 1
}

source /etc/genkernel.conf || small_die "Could not read /etc/genkernel.conf"
source ${GK_BIN}/gen_funcs.sh || small_die "Could not read ${GK_BIN}/gen_funcs.sh"
source ${GK_BIN}/gen_cmdline.sh || gen_die "Could not read ${GK_BIN}/gen_cmdline.sh"
source ${GK_BIN}/gen_arch.sh || gen_die "Could not read ${GK_BIN}/gen_arch.sh"
source ${GK_BIN}/gen_determineargs.sh || gen_die "Could not read ${GK_BIN}/gen_determineargs.sh"
source ${GK_BIN}/gen_compile.sh || gen_die "Could not read ${GK_BIN}/gen_compile.sh"
source ${GK_BIN}/gen_configkernel.sh || gen_die "Could not read ${GK_BIN}/gen_configkernel.sh"
source ${GK_BIN}/gen_initrd.sh || gen_die "Could not read ${GK_BIN}/gen_initrd.sh"
source ${GK_BIN}/gen_initramfs.sh || gen_die "Could not read ${GK_BIN}/gen_initramfs.sh"
source ${GK_BIN}/gen_moddeps.sh || gen_die "Could not read ${GK_BIN}/gen_moddeps.sh"
source ${GK_BIN}/gen_package.sh || gen_die "Could not read ${GK_BIN}/gen_package.sh"
source ${GK_BIN}/gen_bootloader.sh || gen_die "Could not read ${GK_BIN}/gen_bootloader.sh"

TEMP=${TMPDIR}/$RANDOM.$RANDOM.$RANDOM.$$

trap_cleanup(){
	# Call exit code of 1 for failure
	cleanup
	exit 1
}

cleanup(){
    if [ -n "$TEMP" -a -d "$TEMP" ]; then
	rm -rf "$TEMP"
    fi

    if isTrue ${POSTCLEAR}
    then
	    echo
	    print_info 1 'RUNNING FINAL CACHE/TMP CLEANUP'
	    print_info 1 "CACHE_DIR: ${CACHE_DIR}"
	    CLEAR_CACHE_DIR='yes'
	    setup_cache_dir
	    echo
	    print_info 1 "CACHE_CPIO_DIR: ${CACHE_CPIO_DIR}"
	    CLEAR_CPIO_CACHE='yes'
	    clear_cpio_dir
	    echo
	    print_info 1 "TMPDIR: ${TMPDIR}"
	    clear_tmpdir
	    fi
}

trap trap_cleanup SIGHUP SIGQUIT SIGINT SIGTERM SIGKILL
BUILD_KERNEL=0
BUILD_INITRD=0
BUILD_MODULES=0

# Parse all command line options...
Options=$* # Save for later
while [ $# -gt 0 ]
do
	Option=$1; shift
	parse_cmdline $Option
done

# Check if no action is specified...
if [ "${BUILD_KERNEL}" -eq 0 -a "${BUILD_INITRD}" -eq 0 ]
then
	usage
	exit 1
fi

clear_log
NORMAL=${GOOD} print_info 1 "Gentoo Linux Genkernel; Version ${GK_V}${NORMAL}"
print_info 1 "Running with options: ${Options}"
echo

# Set ${ARCH}
get_official_arch

# Read arch-specific config
source ${ARCH_CONFIG} || gen_die "Could not read ${ARCH_CONFIG}"
source ${GK_SHARE}/${ARCH}/modules_load || gen_die "Could not read ${GK_SHARE}/${ARCH}/modules_load"

# Merge modules_load from config
for group_modules in ${!AMODULES_*}; do
	group="$(echo $group_modules | cut -d_ -f2)"
	eval cmodules="\$$group_modules"
	eval MODULES_${group}=\"\${MODULES_${group}} ${cmodules}\"
	print_info 1 "<config> Merged AMODULES_${group}:'${cmodules}' into MODULES_${group}"
done


# Based on genkernel.conf, arch-specific configs, and commandline options,
# get the real arguments for usage...

determine_real_args

[ ! -f "${TEMP}" ] && mkdir -p "${TEMP}"

setup_cache_dir


dump_debugcache

NORMAL=${BOLD} print_info 1 "Linux Kernel ${BOLD}${KV}${NORMAL} for ${BOLD}${ARCH}${NORMAL}..."

if [ "${BUILD_INITRD}" -ne '0' ]
then
	if ! has_loop
	then
		modprobe loop 2>/dev/null
		sleep 3
		if ! has_loop
		then
			print_error 1 'The build-host kernel does not appear to have loop device support.'
			print_error 1 'Please load loop support before running genkernel!'
			gen_die 'Load loop support!'
		else
			print_info 1 'loop: "loop" module loaded successfully...'
		fi
	fi
fi

# Check /boot is mounted
if isTrue ${CMD_NOINSTALL}
then
	isTrue ${MOUNTBOOT} && print_info 2 'Skipping automatic mount of boot'
else
	if ! egrep -q ' /boot ' /proc/mounts
	then
		if egrep -q '^[^#].+	/boot	' /etc/fstab
		then
			if isTrue ${MOUNTBOOT}
			then
				if ! mount /boot
				then
					print_warning 1 "${BOLD}WARNING${NORMAL}: Failed to mount /boot!"
					echo
				else
					print_info 1 'mount: /boot mounted successfully!'
				fi
			else
				print_warning 1 "${BOLD}WARNING${NORMAL}: No mounted /boot partition detected!"
				print_warning 1 '         Run ``mount /boot`` to mount it!'
				echo
			fi
		fi
	elif isBootRO
	then
		if isTrue ${MOUNTBOOT}
		then
			if ! mount -o remount,rw /boot
			then
				print_warning 1 "${BOLD}WARNING${NORMAL}: Failed to remount /boot RW!"
				echo
			else
				print_info 1 "mount: /boot remounted read/write successfully!"
				BOOTRW=1
			fi
		fi
	fi
fi

## Check whether another Genkernel is running
#GENPIDS="`ps -C genkernel --no-headers -o pid | wc -l`"
#if [ "${GENPIDS}" -gt '3' ]
#then
#	[ "${GENPIDS}" -gt '4' ] && EX='s'
#	print_warning 1 "${BOLD}WARNING${NORMAL}: Another Genkernel instance is running under"
#	print_warning 1 "         process ID${EX} " 0
#	GENPIDS=`ps -C genkernel --no-headers -o pid`
#	echo -n "${GENPIDS}" | sed -e "s/$$//; s/ /, /g"
#	echo 'halting...'
#	echo
#	print_warning 1 'Running multiple genkernels on the same source tree will cause data loss!'
#	print_info 1 "Press ^C to halt; ^D to continue [ ${BOLD}if${NORMAL} you know what you're doing! ]"
#	echo
#	CTEMP="${TEMP}"
#	TEMP=${TMPDIR-/tmp}
#	TEMP=${TEMP}/genkernel.$RANDOM.$RANDOM.$RANDOM.$$
#	print_info 1 'thread: Running multiple genkernels may cause problems!'
#	print_info 1 "thread: Temporary files reallocated to ${TEMP}..."
#	echo
#fi

KERNCACHE_IS_VALID=0
if [ "${KERNCACHE}" != "" ] 
then
    gen_kerncache_is_valid
fi

if [ ${BUILD_KERNEL} -eq 1 -a "${KERNCACHE_IS_VALID}" == "0" ]
then
	# Configure kernel
	config_kernel
	
	# Make deps
	compile_dep

	# Make prepare [2.6]
	if [ "${ARCH_HAVENOPREPARE}" = '' ]
	then
		[ "${VER}" -gt '2' ] || [ "${VER}" -eq '2' -a "${PAT}" -ge '6' ] && compile_generic prepare kernel
	fi
	
	# KV may have changed due to the configuration
	get_KV

	# Compile kernel; If using --genzimage, or building a mips kernel, skip compile
	# till after initrd/initramfs is done
	[ "${GENERATE_Z_IMAGE}" = '' -a ${BUILD_INITRAMFS} -eq 0 ] && compile_kernel

	# Compile modules
	if [ ${BUILD_MODULES} -eq 1 -a ${BUILD_STATIC} -eq 0 ]
	then
		compile_modules
	fi

	if [ ${SAVE_CONFIG} -eq 1 ]
	then
		print_info 1 "Copying config for successful build to /etc/kernels/kernel-config-${ARCH}-${KV}"
		[ ! -e '/etc/kernels' ] && mkdir -p /etc/kernels
		cp "${KERNEL_DIR}/.config" "/etc/kernels/kernel-config-${ARCH}-${KV}"
	fi
	if [ "${KERNCACHE}" != "" ]
	then
		if [ "${GENERATE_Z_IMAGE}" = '' -a ${BUILD_INITRAMFS} -eq 0 ]
		then
			gen_kerncache
		fi
	fi
fi

if ! isTrue "${CMD_NOINSTALL}"
then
	if [ "${KERNCACHE}" != "" -a "${KERNCACHE_IS_VALID}" != "0" ] 
	then
		gen_kerncache_extract_kernel
	fi
fi

if [ "${KERNCACHE}" != "" -a "${KERNCACHE_IS_VALID}" != "0" ] 
then
	[ ${BUILD_STATIC} -eq 0 ] && gen_kerncache_extract_modules
	gen_kerncache_extract_config
fi


# Run callback
if [ "${CMD_CALLBACK}" != "" ]
then
	print_info 1 "" 1 0
	print_info 1 "Preparing to run callback: \"${CMD_CALLBACK}\"" 0

	CALLBACK_ESCAPE=0
	CALLBACK_COUNT=0

	trap "CALLBACK_ESCAPE=1" TERM KILL INT QUIT ABRT
	while [[ ${CALLBACK_ESCAPE} -eq 0 && ${CALLBACK_COUNT} -lt 5 ]]
	do
		sleep 1; echo -n '.';
		let CALLBACK_COUNT=${CALLBACK_COUNT}+1
	done

	if [ "${CALLBACK_ESCAPE}" -eq 0 ]
	then
		echo
		echo
		eval ${CMD_CALLBACK} | tee -a ${DEBUGFILE}
		CMD_STATUS="${PIPESTATUS[0]}"
		echo
		print_info 1 "<<< Callback exit status: ${CMD_STATUS}"
		[ "${CMD_STATUS}" -ne 0 ] && gen_die '--callback failed!'
	else
		echo
		print_info 1 ">>> Callback cancelled..."
	fi
	trap - TERM KILL INT QUIT ABRT
	print_info 1 "" 1 0
fi

if [ "${BUILD_INITRD}" -eq '1' ]
then
	# Only compile insmod if we're installing modules onto the initrd
	if [ "${NOINITRDMODULES}" = '' ]
	then
		if [ "${KERN_24}" != '1' ]
		then
			# Compile module-init-tools
			[ ${BUILD_STATIC} -eq 0 ] && compile_module_init_tools
		else
			[ ${BUILD_STATIC} -eq 0 ] && compile_modutils
		fi
	fi
	
	[ "${DISKLABEL}" -eq '1' ] && compile_e2fsprogs

	if [ "${KERN_24}" != '1' -a "${UDEV}" -eq '1' ] 
	then
		compile_udev 
	else
		DEVFS=1
		UDEV=0
		compile_devfsd
	fi

	if [ "${KERN_24}" != '1' -a  "${CMD_BOOTSPLASH}" != '1' ]
	then
	    if [ "${BUSYBOX}" -eq '1' ]
	    then
		# Compile Busybox
		compile_busybox
	    fi
	    
	    # Compile initramfs
	    create_initramfs
	else
	    # Create initrd
	    compile_busybox
	    create_initrd
	fi
else
	print_info 1 'initrd: Not building since only the kernel was requested...'
fi

# Pegasos fix
if [ "${GENERATE_Z_IMAGE}" != '' -o ${BUILD_INITRAMFS} -eq 1 ]
then
	# Compile kernel, intergrating the initrd into it for Pegasos & mips
	compile_kernel

	# We skipped the kernel build and kerncache generation
	# So do it here
	[ "${KERNCACHE}" != "" ] && gen_kerncache
fi

[ "${MINKERNPACKAGE}" != '' ] && gen_minkernpackage
[ "${MODULESPACKAGE}" != '' ] && gen_modulespackage

# Clean up...
[ -n "${CTEMP}" ] && rm -rf "${TEMP}"

if [ "${BUILD_KERNEL}" -eq '1' ]
then
	set_bootloader
	print_info 1 ''
	print_info 1 "Kernel compiled successfully!"
	print_info 1 ''
	print_info 1 'Required Kernel Parameters:'
	if [ "${BUILD_INITRD}" -eq '0' ]
	then
		print_info 1 '    root=/dev/$ROOT'
		print_info 1 '    [ And "vga=0x317 splash=verbose" if you use a framebuffer ]'
		print_info 1 ''
		print_info 1 '    Where $ROOT is the device node for your root partition as the'
		print_info 1 '    one specified in /etc/fstab'
	elif [ "${KERN_24}" != '1' -a  "${CMD_BOOTSPLASH}" != '1' ]
	then
		print_info 1 '    real_root=/dev/$ROOT'
		print_info 1 ''
		print_info 1 '    Where $ROOT is the device node for your root partition as the'
		print_info 1 '    one specified in /etc/fstab'
		print_info 1 ''
		print_info 1 "If you require Genkernel's hardware detection features; you MUST"
		print_info 1 'tell your bootloader to use the provided INITRAMFS file. Otherwise;'
		print_info 1 'substitute the root argument for the real_root argument if you are'
		print_info 1 'not planning to use the initrd...'
	else	
		print_info 1 '    root=/dev/ram0 real_root=/dev/$ROOT init=/linuxrc'
		[ "${INITRD_SIZE}" -ge 4096 ] && print_info 1 "    ramdisk_size=${INITRD_SIZE}"
		print_info 1 ''
		print_info 1 '    Where $ROOT is the device node for your root partition as the'
		print_info 1 '    one specified in /etc/fstab'
		print_info 1 ''
		print_info 1 "If you require Genkernel's hardware detection features; you MUST"
		print_info 1 'tell your bootloader to use the provided INITRD file. Otherwise;'
		print_info 1 'substitute the root argument for the real_root argument if you are'
		print_info 1 'not planning to use the initrd...'
	fi
fi

if [ "${BUILD_INITRD}" -eq '1' ]
then
	echo
	print_info 1 'WARNING... WARNING... WARNING...'
	print_info 1 'Additional kernel cmdline arguments that *may* be required to boot properly...'
	[ "${GENSPLASH}" -eq '1' ] && print_info 1 "add \"vga=791 splash=silent,theme:${GENSPLASH_THEME} CONSOLE=/dev/tty1 quiet\" if you use a gensplash framebuffer ]"
	[ "${BOOTSPLASH}" -eq '1' ] && print_info 1 'add "vga=791 splash=silent" if you use a bootsplash framebuffer'
	[ "${LVM2}" -eq '1' ] && print_info 1 'add "dolvm2" for lvm2 support'
	[ "${EVMS2}" -eq '1' ] && print_info 1 'add "doevms2" for evms support'
	[ "${DMRAID}" -eq '1' ] && print_info 1 'add "dodmraid" for dmraid support'
	[ "${DMRAID}" -eq '1' ] && print_info 1 '	or "dodmraid=<additional options>"'
	[ "${UNIONFS}" -eq '1' ] && print_info 1 'add "unionfs" for unionfs support'
	[ "${UNIONFS}" -eq '1' ] && print_info 1 '	or "unionfs=<block_device>"'
fi

if [ "${CMD_NOINSTALL}" != '1' -a "${SYMLINK}" = '1' ]
then 
    echo
    print_info 1 'Creating symlinks'
    
    
    print_info 1 '	    creating kernel name symlink!'
    if [ -e /boot/kernel-${KNAME}-${ARCH}-${KV} ]
    then
	/bin/rm /boot/kernel
        ln -s /boot/kernel-${KNAME}-${ARCH}-${KV} /boot/kernel
        ret=$?
        [ ${ret} = '1' ] && print_error 1 'kernel link failed'
    fi
    
    if [ "${KERN_24}" != '1' -a  "${CMD_BOOTSPLASH}" != '1' ]
    then
	print_info 1 '	    creating initramfs name symlink!'
	if [ -e /boot/initramfs-${KNAME}-${ARCH}-${KV} ]
	then
	    /bin/rm /boot/initramfs
	    ln -s /boot/initramfs-${KNAME}-${ARCH}-${KV} /boot/initramfs
	    ret=$?
	    [ ${ret} = '1' ] && print_error 1 'initramfs link failed'
	fi
    else
	print_info 1 '	    creating initrd name symlink!'
	if [ -e /boot/initrd-${KNAME}-${ARCH}-${KV} ]
	then
	    /bin/rm /boot/initrd
	    ln -s /boot/initrd-${KNAME}-${ARCH}-${KV} /boot/initrd
	    ret=$?
	    [ ${ret} = '1' ] && print_error 1 'initrd link failed'
	fi
    fi
fi


[ "${BOOTRW}" != '' ] && mount -o remount,ro /boot

echo
print_info 1 'Do NOT report kernel bugs as genkernel bugs unless your bug'
print_info 1 'is about the default genkernel configuration...'
print_info 1 ''
print_info 1 'Make sure you have the latest genkernel before reporting bugs.'

#Final Cleanup
cleanup
